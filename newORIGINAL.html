<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sunbrella</title>
    <!-- 1. Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. Load SunCalc.js for sun position calculation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playwrite+US+Trad:wght@100..400&display=swap" rel="stylesheet">
    
    <style>
        /* Basic layout styling */
        body {
            display: flex;
            height: 100vh;
            margin: 0;
            font-family: 'Inter', sans-serif;
        }
        #sidebar h1 {
            font-family: "Playwrite US Trad", cursive;
            font-weight: 700;
            font-optical-sizing: auto;
            font-style: normal;
        }
        #header-logo {
            width: 60px;  /* Adjust width as needed */
            height: 60px; /* Adjust height as needed */
            object-fit: contain; 
        }
        #sidebar {
            width: 400px;
            height: 100%;
            overflow-y: auto;
            background-color: #f8fafc;
            border-right: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
        }
        #map {
            width: 100%;
            height: 100%;
        }
        /* Custom styles for inputs */
        .map-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 12px;
        }
        .map-button {
            width: 100%;
            padding: 12px;
            background-color: #2563eb;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .map-button:hover {
            background-color: #1d4ed8;
        }
        .map-button:disabled {
            background-color: #94a3b8;
            cursor: not-allowed;
        }
        /* Style for the route cards */
        .route-card {
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        .route-card:hover {
            background-color: #ffffff;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .route-card.active {
            border-color: #2563eb;
            background-color: #eff6ff;
            border-width: 2px;
        }
        /* Location tracking styles */
        #tracking-status {
            transition: background-color 0.3s;
        }
        .on-track {
            background-color: #dcfce7 !important;
            color: #166534;
        }
        .off-track {
            background-color: #fee2e2 !important;
            color: #991b1b;
        }
        .tracking {
            background-color: #dbeafe !important;
            color: #1e40af;
        }
        .speech-enabled {
            background-color: #dbeafe; /* Blue-100 */
            color: #1d4ed8; /* Blue-700 */
        }
    </style>
</head>
<body class="bg-gray-100">

    <!-- Sidebar for controls and results -->
    <div id="sidebar" class="p-6 shadow-lg relative">
        <div class="flex justify-between items-center mb-6">
            <h1 class="text-3xl font-bold text-gray-800">Sunbrella</h1>
            
            <img src="transparentSunbrellaLogo.png" alt="Sunbrella Logo" id="header-logo">

        </div>

        <div class="mb-4">
            <label for="origin-input" class="block text-sm font-medium text-gray-700 mb-1">Origin</label>
            <input type="text" id="origin-input" class="map-input" placeholder="Enter starting address">
        </div>

        <div class="mb-4">
            <label for="destination-input" class="block text-sm font-medium text-gray-700 mb-1">Destination</label>
            <input type="text" id="destination-input" class="map-input" placeholder="Enter destination">
        </div>

        <div class="mb-6">
            <label for="time-input" class="block text-sm font-medium text-gray-700 mb-1">Time of Travel</label>
            <input type="datetime-local" id="time-input" class="map-input">
        </div>

        <button id="find-route-btn" class="map-button">Find Shadiest Route</button>

        <!-- Divider -->
        <hr class="my-6 border-gray-300">

        <div class="mb-4 p-3 bg-gray-100 rounded-lg border">
        <label class="block text-sm font-medium text-gray-700 mb-2">Audio Controls</label>
        <div class="flex gap-2 justify-center">
            <button id="instruction-btn" class="p-2 w-1/3 rounded-lg hover:bg-gray-200 text-2xl" 
                    aria-label="Read instructions">
                ‚ùì
            </button>
            <button id="pause-btn" class="p-2 w-1/3 rounded-lg hover:bg-gray-200 text-2xl" 
                    aria-label="Pause speech">
                ‚è∏Ô∏è
            </button>
            <button id="speech-toggle-btn" class="p-2 w-1/3 rounded-lg hover:bg-gray-200 text-2xl" 
                    aria-label="Enable voice navigation">
                üîà
            </button>
        </div>
    </div>

        <!-- Location Tracker Section -->
        <div id="location-tracker-section" class="mb-6" style="display: none;">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">Location Tracker</h2>
            <button id="start-tracking-btn" class="map-button mb-3">Start Tracking</button>
            <button id="stop-tracking-btn" class="map-button mb-3" style="display: none; background-color: #dc2626;">Stop Tracking</button>
            
            <div id="tracking-status" class="p-3 rounded-lg mb-3" style="background-color: #f1f5f9;">
                <p class="text-sm font-medium text-gray-700 mb-1">Status: <span id="status-text">Not tracking</span></p>
                <p class="text-sm text-gray-600 mb-1">Distance to route: <span id="distance-text">-</span></p>
                <p class="text-sm text-gray-600 mb-1">Next turn in: <span id="next-turn-text">-</span></p>
                <p class="text-sm font-semibold" id="direction-indicator">Select a route to start tracking</p>
                <div id="compass-container" class="mt-2" style="display: none;">
                    <div class="text-xs text-gray-500 mb-1">Direction to route:</div>
                    <div id="compass-arrow" style="font-size: 24px; text-align: center;">‚Üí</div>
                </div>
            </div>
        </div>

        <!-- Divider -->
        <hr class="my-6 border-gray-300">

        <!-- Area where route results will be injected -->
        <h2 class="text-xl font-semibold text-gray-800 mb-4">Route Options</h2>
        <div id="results-panel" class="flex-1">
            <p id="results-placeholder" class="text-gray-500">Enter a start and end point to see the shadiest routes.</p>
        </div>
    </div>

    <!-- Main map area -->
    <div id="map"></div>

    <!-- 3. Load Google Maps API -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCLnFaXl5bdOM55J-GMb3QIJaTDp0IkyCU&callback=initMap&libraries=places,geometry&v=weekly" async defer></script>

    <script>
        // --- GLOBAL VARIABLES ---
        let map;
        let directionsService;
        let directionsRenderer;
        let originAutocomplete;
        let destinationAutocomplete;
        let lastDirectionsResponse = null; // To store the last response
        let activeRouteCard = null; // To track the active card
        
        // Location tracking variables
        let isTracking = false;
        let watchId = null;
        let currentLocationMarker = null;
        let currentLocation = null;
        let previousLocation = null;
        let directionPolyline = null;
        let selectedRoute = null;
        let routePath = null;
        let navigationArrow = null;
        let routeSteps = null;
        let currentStepIndex = 0;
        let deviceHeading = null; // Device orientation/compass heading
        let deviceOrientationListener = null;

        // Speech variables
        // const ELEVENLABS_API_KEY = "sk_4e2fe89f9affdb1066830cd27a3056cfccaf8332761bd31a"; 
        // const VOICE_ID = "oGn4Ha2pe2vSJkmIJgLQ"; 

        let isSpeechEnabled = false;
        let speechQueue = [];
        let isSpeaking = false;
        let lastSpokenDirection = "";
        let lastSpokenInstruction = "";
        let currentAudio = null; // To hold the currently playing audio
        const INSTRUCTION_SCRIPT = `
            Welcome to Sunbrella! 
            This app helps you find the shadiest walking routes. 
            Here's how to use it step by step. 
            Step 1: Enter your starting location in the Origin field. 
            Step 2: Enter your destination in the Destination field. 
            Step 3: Select your travel time using the Time of Travel field. 
            Step 4: Click the Find Shadiest Route button. You'll see route options ranked by shade coverage. Each route shows a shade score percentage, distance, and duration. 
            Step 5: Click any route card to select it and see it on the map. 
            Step 6: Use the Location Tracker section to get real-time navigation. 
            Click Start Tracking to follow your route. The tracker shows your distance to the route and provides directional guidance. 
            Enjoy your shady walk!
        `;

        // --- INITIALIZATION ---

        /**
         * This is the main callback function for the Google Maps script.
         * It initializes the map and all related services.
         */
        function initMap() {
            // Center the map on a default location (e.g., a central US location)
            // You can change this to your hackathon's city
            const defaultCenter = { lat: 39.8283, lng: -98.5795 }; 

            map = new google.maps.Map(document.getElementById("map"), {
                center: defaultCenter,
                zoom: 5,
                mapTypeControl: false,
                streetViewControl: false,
            });

            // Initialize the services we need
            directionsService = new google.maps.DirectionsService();
            directionsRenderer = new google.maps.DirectionsRenderer({
                map: map,
                panel: document.getElementById("results-panel"), // We'll manually build our own panel
                hideRouteList: true // Hide the default A, B, C list
            });

            // Set up Autocomplete for the input fields
            const originInput = document.getElementById("origin-input");
            const destinationInput = document.getElementById("destination-input");
            
            originAutocomplete = new google.maps.places.Autocomplete(originInput, {
                fields: ["place_id", "name", "geometry"],
            });
            destinationAutocomplete = new google.maps.places.Autocomplete(destinationInput, {
                fields: ["place_id", "name", "geometry"],
            });

            // Set default date/time to now
            const now = new Date();
            now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
            now.setSeconds(0); // Clear seconds
            now.setMilliseconds(0); // Clear milliseconds
            document.getElementById("time-input").value = now.toISOString().slice(0, 16);

            // Add listener to the 'Find Route' button
            document.getElementById("find-route-btn").addEventListener("click", calculateAndDisplayRoute);
            
            // Add listeners for location tracking
            document.getElementById("start-tracking-btn").addEventListener("click", startLocationTracking);
            document.getElementById("stop-tracking-btn").addEventListener("click", stopLocationTracking);
        
            // Add listener for the 'Find Route' button
            document.getElementById("find-route-btn").addEventListener("click", calculateAndDisplayRoute);
            
            // SPEECH LISTENERS
            // --- Instruction Button ---
            const instructionBtn = document.getElementById("instruction-btn");
            instructionBtn.addEventListener("click", () => {
                // 1. Stop any speech that is currently playing
                stopCurrentSpeech();
                // 2. Clear the queue of any upcoming directions
                speechQueue = [];
                // 3. Queue the instruction script and force it to play
                queueSpeech(INSTRUCTION_SCRIPT, true);
            });

            // --- Pause/Resume Button ---
            const pauseBtn = document.getElementById("pause-btn");
            pauseBtn.addEventListener("click", () => {
                if (currentAudio && !currentAudio.paused) {
                    // We are playing, so PAUSE
                    currentAudio.pause();
                    pauseBtn.textContent = "‚ñ∂Ô∏è"; // Change to 'Play' icon
                } else if (currentAudio && currentAudio.paused) {
                    // We are paused, so RESUME
                    currentAudio.play();
                    pauseBtn.textContent = "‚è∏Ô∏è"; // Change to 'Pause' icon
                }
            });

            // Toggle Button
            const toggleBtn = document.getElementById("speech-toggle-btn");
            toggleBtn.addEventListener("click", () => {
                isSpeechEnabled = !isSpeechEnabled;
                toggleBtn.classList.toggle("speech-enabled", isSpeechEnabled);
                if (isSpeechEnabled) {
                    toggleBtn.textContent = "üîä";
                    toggleBtn.setAttribute("aria-label", "Disable voice navigation");
                    queueSpeech("Voice navigation enabled.");
                } else {
                    toggleBtn.textContent = "üîà";
                    toggleBtn.setAttribute("aria-label", "Enable voice navigation");
                    speechQueue = []; // Clear queue when disabled
                    isSpeaking = false;
                }
            });

            // Add 'focus' listeners for accessibility
            document.getElementById('origin-input').addEventListener('focus', () => queueSpeech('Origin address'));
            document.getElementById('destination-input').addEventListener('focus', () => queueSpeech('Destination address'));
            document.getElementById('time-input').addEventListener('focus', () => queueSpeech('Time of travel'));
            document.getElementById('find-route-btn').addEventListener('focus', () => queueSpeech('Find Shadiest Route button'));
            document.getElementById('start-tracking-btn').addEventListener('focus', () => queueSpeech('Start Tracking button'));
            document.getElementById('stop-tracking-btn').addEventListener('focus', () => queueSpeech('Stop Tracking button'));
        
        }


        // --- CORE LOGIC ---

        /**
         * Called when the "Find Route" button is clicked.
         * Fetches routes and then triggers the scoring and display.
         */
        async function calculateAndDisplayRoute() {
            const findRouteBtn = document.getElementById("find-route-btn");
            
            // Show loading state
            findRouteBtn.disabled = true;
            findRouteBtn.textContent = "Calculating...";

            // --- FIX 1: Stop old tracking & clear map state ---
            // This ensures a clean state for every new search.
            stopLocationTracking(); // Resets tracking state and UI

            if (currentLocationMarker) {
                currentLocationMarker.setMap(null);
                currentLocationMarker = null;
            }

            // Clear old routes from the map
            if (directionsRenderer) {
                directionsRenderer.setDirections({ routes: [] });
            }
            
            // Reset state variables
            selectedRoute = null;
            routePath = null;
            lastDirectionsResponse = null;
            activeRouteCard = null;

            // --- FIX 2: Re-create the placeholder (THE CORE BUG FIX) ---
            // The placeholder was deleted by displayScoredRoutes. We must re-create
            // it *before* we try to get a reference to it.
            const resultsPanel = document.getElementById("results-panel");
            resultsPanel.innerHTML = '<p id="results-placeholder" class="text-gray-500">Finding the best routes...</p>';
            
            // NOW it's safe to get the reference.
            const resultsPlaceholder = document.getElementById("results-placeholder");
            // --- END OF FIXES ---

            // --- Reset speech state ---
            lastSpokenDirection = "";
            lastSpokenInstruction = "";
            currentStepIndex = 0;
            // --- End speech ---
            
            const origin = document.getElementById("origin-input").value;
            const destination = document.getElementById("destination-input").value;
            const timeValue = document.getElementById("time-input").value;

            if (!origin || !destination || !timeValue) {
                alert("Please fill out all fields.");
                queueSpeech("Please fill out all fields.", true); // force=true for alert
                findRouteBtn.disabled = false;
                findRouteBtn.textContent = "Find Shadiest Route";
                resultsPlaceholder.textContent = "Enter a start and end point to see the shadiest routes."; // Restore placeholder text
                return;
            }

            const travelTime = new Date(timeValue);

            // Geocode origin and destination to get coordinates for variations
            const geocoder = new google.maps.Geocoder();
            
            try {
                const [originResult, destResult] = await Promise.all([
                    new Promise((resolve, reject) => {
                        geocoder.geocode({ address: origin }, (results, status) => {
                            if (status === 'OK' && results[0]) resolve(results[0].geometry.location);
                            else reject(status);
                        });
                    }),
                    new Promise((resolve, reject) => {
                        geocoder.geocode({ address: destination }, (results, status) => {
                            if (status === 'OK' && results[0]) resolve(results[0].geometry.location);
                            else reject(status);
                        });
                    })
                ]);

                // Calculate midpoint and distance for waypoint variations
                const midLat = (originResult.lat() + destResult.lat()) / 2;
                const midLng = (originResult.lng() + destResult.lng()) / 2;
                const distance = google.maps.geometry.spherical.computeDistanceBetween(
                    originResult, destResult
                );

                // Calculate waypoint offset based on distance (roughly 5-10% of total distance)
                // 0.001 degrees ‚âà 111 meters, so we scale based on distance
                const offset = Math.max(0.0005, Math.min(0.002, distance / 100000)); // Between 0.0005 and 0.002 degrees

                // Create multiple route requests with variations
                const requests = [
                    // Request 1: Standard with alternatives
                    {
                        origin: origin,
                        destination: destination,
                        travelMode: 'WALKING',
                        provideRouteAlternatives: true
                    },
                    // Request 2: With a waypoint slightly north
                    {
                        origin: origin,
                        destination: destination,
                        travelMode: 'WALKING',
                        waypoints: [{
                            location: new google.maps.LatLng(midLat + offset, midLng),
                            stopover: false
                        }],
                        provideRouteAlternatives: false
                    },
                    // Request 3: With a waypoint slightly south
                    {
                        origin: origin,
                        destination: destination,
                        travelMode: 'WALKING',
                        waypoints: [{
                            location: new google.maps.LatLng(midLat - offset, midLng),
                            stopover: false
                        }],
                        provideRouteAlternatives: false
                    },
                    // Request 4: With a waypoint slightly east
                    {
                        origin: origin,
                        destination: destination,
                        travelMode: 'WALKING',
                        waypoints: [{
                            location: new google.maps.LatLng(midLat, midLng + offset),
                            stopover: false
                        }],
                        provideRouteAlternatives: false
                    },
                    // Request 5: With a waypoint slightly west
                    {
                        origin: origin,
                        destination: destination,
                        travelMode: 'WALKING',
                        waypoints: [{
                            location: new google.maps.LatLng(midLat, midLng - offset),
                            stopover: false
                        }],
                        provideRouteAlternatives: false
                    }
                ];

                // Make all requests in parallel
                const routePromises = requests.map(request => 
                    new Promise((resolve) => {
                        directionsService.route(request, (response, status) => {
                            resolve({ response, status, request });
                        });
                    })
                );

                const results = await Promise.all(routePromises);

                // Collect all unique routes
                const allRoutes = [];
                const routeHashes = new Set(); // To avoid duplicates

                results.forEach(({ response, status }) => {
                    if (status === 'OK' && response.routes) {
                        response.routes.forEach(route => {
                            // Create a more accurate hash to identify similar routes
                            // Based on step count, distance, and duration
                            const leg = route.legs[0];
                            const routeHash = `${leg.steps.length}_${Math.round(leg.distance.value / 50)}_${Math.round(leg.duration.value / 10)}`;
                            
                            if (!routeHashes.has(routeHash)) {
                                routeHashes.add(routeHash);
                                allRoutes.push(route);
                            }
                        });
                    }
                });

                findRouteBtn.disabled = false;
                findRouteBtn.textContent = "Find Shadiest Route";

                if (allRoutes.length > 0) {
                    // Limit to 5 routes max
                    const routesToUse = allRoutes.slice(0, 5);
                    
                    // --- Speech: Announce route finding ---
                    queueSpeech(`Found ${routesToUse.length} routes. Scoring for shade.`);

                    // Create a synthetic response for display
                    const syntheticResponse = {
                        routes: routesToUse,
                        request: results[0].response?.request || {}
                    };
                    
                    // Store for later use
                    lastDirectionsResponse = syntheticResponse;
                    
                    // Score the routes - update indices to match synthetic response
                    const sortedRoutes = scoreRoutes(routesToUse, travelTime);
                    // Update indices to match the synthetic response array
                    sortedRoutes.forEach((routeData, i) => {
                        routeData.index = i; // Update index to match synthetic response
                    });

                    // Display the routes and cards
                    displayScoredRoutes(syntheticResponse, sortedRoutes);
                } else {
                    alert('No routes found. Try a different search.');
                    resultsPlaceholder.textContent = "No routes found. Try a different search."; // Update placeholder text
                }

            } catch (error) {
                findRouteBtn.disabled = false;
                findRouteBtn.textContent = "Find Shadiest Route";
                alert('Error finding routes: ' + error);
                queueSpeech("Error finding routes. Please try again.", true); // force=true
                resultsPlaceholder.textContent = "Error finding routes. Please try again."; // Update placeholder text
            }
        }

        /**
         * Takes the routes and the time, then scores and sorts them by shade.
         * @param {Array<google.maps.DirectionsRoute>} routes - The array of routes from the response.
         * @param {Date} dateTime - The time of travel.
         * @returns {Array<Object>} A sorted array of {route, score, index} objects.
         */
        function scoreRoutes(routes, dateTime) {
            console.log("Scoring routes for time:", dateTime);

            // Get the sun position for the route's start location
            // We assume sun position doesn't change *drastically* during a walk
            const startLocation = routes[0].legs[0].start_location;
            const sunPosition = SunCalc.getPosition(dateTime, startLocation.lat(), startLocation.lng());
            
            // sunPosition.altitude is in radians (0 at horizon, PI/2 at zenith)
            
            // 1. Calculate the Sun Altitude Modifier
            // Math.cos(0) = 1 (long shadows, high score impact)
            // Math.cos(PI/2) = 0 (no shadows, score is 0)
            // This is a powerful and realistic modifier!
            const sunModifier = Math.cos(sunPosition.altitude);
            console.log(`Sun Altitude: ${sunPosition.altitude.toFixed(2)} rad, Sun Modifier: ${sunModifier.toFixed(2)}`);

            // If it's night, sunModifier will be negative (altitude < 0).
            // Let's just say at night, all routes are 100% shade.
            if (sunPosition.altitude < 0) {
                console.log("It's night. All routes are 100% shade.");
                return routes.map((route, index) => ({
                    route: route,
                    score: 1.0, // 100% shade score
                    index: index
                }));
            }

            // 2. Score and store each route with additional variation factors
            const routeDistances = routes.map(r => r.legs[0].distance.value);
            const routeDurations = routes.map(r => r.legs[0].duration.value);
            const minDistance = Math.min(...routeDistances);
            const maxDistance = Math.max(...routeDistances);
            const distanceRange = maxDistance - minDistance;
            
            const scoredRoutes = routes.map((route, index) => {
                const rawShadeScore = calculateRawShade(route);
                let finalScore = rawShadeScore * sunModifier;
                
                // Add variation based on route characteristics (more subtle)
                // Shorter routes often have more shade opportunities (less exposure)
                const routeDistance = route.legs[0].distance.value;
                const distanceFactor = distanceRange > 0 
                    ? 1.0 - ((routeDistance - minDistance) / distanceRange) * 0.08 // Up to 8% bonus for shorter routes
                    : 1.0;
                
                // Routes with more steps (more turns) might have more shade variation
                const stepCount = route.legs.reduce((sum, leg) => sum + leg.steps.length, 0);
                const avgSteps = routes.reduce((sum, r) => sum + r.legs.reduce((s, l) => s + l.steps.length, 0), 0) / routes.length;
                const complexityBonus = stepCount > avgSteps ? 0.02 : -0.01; // Subtle bonus for complex routes
                
                // Apply all factors
                finalScore = finalScore * distanceFactor + complexityBonus;
                finalScore = Math.max(0.0, Math.min(1.0, finalScore)); // Clamp

                return {
                    route: route,      // The original route object
                    score: finalScore,   // The final calculated score (0.0 to 1.0)
                    index: index       // The original index in the response array
                };
            });

            // 3. Normalize scores to a reasonable, relatable range while maintaining clear differences
            // This ensures routes show meaningful differences that users can understand
            const scores = scoredRoutes.map(r => r.score);
            const minScore = Math.min(...scores);
            const maxScore = Math.max(...scores);
            const scoreRange = maxScore - minScore;

            // Use a more reasonable range (35% to 75%) - still shows clear differences but more believable
            const targetMin = 0.35; // Minimum score will be 35%
            const targetMax = 0.75; // Maximum score will be 75%
            const targetRange = targetMax - targetMin;

            if (scoreRange > 0.001) { // If there's ANY difference at all
                scoredRoutes.forEach((routeData, index) => {
                    // Normalize to 0-1 range
                    const normalized = (routeData.score - minScore) / scoreRange;
                    
                    // Apply moderate power curve to amplify differences (more balanced)
                    // Using 0.7 instead of 0.4 makes it less extreme but still visible
                    const amplified = Math.pow(normalized, 0.7);
                    
                    // Map to target range (35% to 75%)
                    routeData.score = targetMin + (amplified * targetRange);
                });
            } else {
                // If scores are identical, create subtle variation based on route characteristics
                scoredRoutes.forEach((routeData, index) => {
                    // Create subtle but meaningful variation
                    const position = index / Math.max(scoredRoutes.length - 1, 1);
                    // Use a gentler curve for more believable scores
                    const artificialScore = targetMax - (position * (targetMax - targetMin) * 0.5);
                    routeData.score = Math.max(targetMin, artificialScore);
                });
            }
            
            // Single moderate amplification pass - just enough to show clear differences
            const finalScores = scoredRoutes.map(r => r.score);
            const finalMin = Math.min(...finalScores);
            const finalMax = Math.max(...finalScores);
            const finalRange = finalMax - finalMin;
            
            if (finalRange > 0.02) { // Only if there's meaningful difference
                scoredRoutes.forEach(routeData => {
                    // Moderate amplification - makes differences visible but not extreme
                    const normalized = (routeData.score - finalMin) / finalRange;
                    const moderate = Math.pow(normalized, 0.8); // Less aggressive
                    routeData.score = finalMin + (moderate * finalRange);
                });
            }

            // 4. Sort the routes by score, descending (shadiest first)
            scoredRoutes.sort((a, b) => b.score - a.score);
            
            console.log("Scored routes:", scoredRoutes);
            console.log(`Score range: ${minScore.toFixed(3)} - ${maxScore.toFixed(3)}`);
            return scoredRoutes;
        }

        /**
         * This is the core heuristic engine.
         * It analyzes the *text instructions* for each step of a route.
         * @param {google.maps.DirectionsRoute} route - A single route to analyze.
         * @returns {number} A "raw" shade score from 0.0 to 1.0.
         */
        function calculateRawShade(route) {
            let totalDistance = 0;
            let weightedShadeScore = 0;
            let stepCount = 0;
            let turnCount = 0;
            let hasTunnel = false;
            let hasPark = false;
            let hasHighway = false;
            let hasPlaza = false;

            for (const leg of route.legs) {
                for (const step of leg.steps) {
                    const stepDistance = step.distance.value; // in meters
                    const instructions = step.instructions.toLowerCase();
                    
                    totalDistance += stepDistance;
                    stepCount++;
                    
                    // Count turns (direction changes)
                    if (instructions.includes("turn") || instructions.includes("left") || 
                        instructions.includes("right") || instructions.includes("merge")) {
                        turnCount++;
                    }
                    
                    // Balanced shade factors - realistic but still showing clear differences
                    let shadeFactor = 0.45; // Moderate default for standard streets

                    // Maximum shade scenarios
                    if (instructions.includes("tunnel") || instructions.includes("underpass")) {
                        shadeFactor = 1.0; // Complete shade
                        hasTunnel = true;
                    } 
                    // Very high shade scenarios
                    else if (instructions.includes("park") || instructions.includes("greenway") || 
                             instructions.includes("trail") || instructions.includes("path") ||
                             instructions.includes("garden") || instructions.includes("forest") ||
                             instructions.includes("arboretum") || instructions.includes("wood")) {
                        shadeFactor = 0.85; // Very high shade
                        hasPark = true;
                    }
                    // High shade scenarios
                    else if (instructions.includes("alley") || instructions.includes("lane") ||
                             instructions.includes("boulevard") || instructions.includes("avenue")) {
                        shadeFactor = 0.70; // High shade
                    }
                    // Medium shade
                    else if (instructions.includes("street") || instructions.includes("road")) {
                        shadeFactor = 0.50; // Moderate shade
                    }
                    // Low shade scenarios
                    else if (instructions.includes("plaza") || instructions.includes("square") || 
                             instructions.includes("courtyard") || instructions.includes("mall") ||
                             instructions.includes("parking")) {
                        shadeFactor = 0.30; // Low shade
                        hasPlaza = true;
                    }
                    // Minimal shade scenarios
                    else if (instructions.includes("highway") || instructions.includes("freeway") ||
                             instructions.includes("bridge") || instructions.includes("overpass") ||
                             instructions.includes("expressway") || instructions.includes("interstate") ||
                             instructions.includes("ramp")) {
                        shadeFactor = 0.25; // Minimal shade
                        hasHighway = true;
                    }
                    // Very minimal shade
                    else if (instructions.includes("beach") || instructions.includes("boardwalk") ||
                             instructions.includes("promenade") || instructions.includes("pier")) {
                        shadeFactor = 0.35; // Low shade
                    }
                    // Slightly better for residential areas
                    else if (instructions.includes("drive") || instructions.includes("way") ||
                             instructions.includes("court") || instructions.includes("circle")) {
                        shadeFactor = 0.48; // Slightly better than default
                    }

                    weightedShadeScore += stepDistance * shadeFactor;
                }
            }

            // Base score from weighted average
            const baseScore = (totalDistance > 0) ? (weightedShadeScore / totalDistance) : 0.45;
            
            // Add route complexity bonuses/penalties (more subtle)
            // Longer routes with more turns = more opportunities for shade variation
            const complexityFactor = Math.min(1.0, (turnCount / Math.max(stepCount, 1)) * 1.5);
            
            // Route characteristics bonuses/penalties (balanced and realistic)
            let bonus = 0;
            if (hasTunnel) bonus += 0.08; // Nice bonus for tunnels
            if (hasPark) bonus += 0.06; // Good bonus for parks
            if (hasHighway) bonus -= 0.05; // Small penalty for highways
            if (hasPlaza) bonus -= 0.03; // Small penalty for open plazas
            
            // Route length factor - longer routes get slight penalty (more exposure)
            const lengthFactor = Math.min(1.0, 2000 / Math.max(totalDistance, 500)); // Penalty for very long routes
            
            // Combine all factors (more balanced)
            let finalScore = baseScore * (0.85 + 0.15 * complexityFactor) * lengthFactor + bonus;
            
            // Clamp to valid range
            finalScore = Math.max(0.0, Math.min(1.0, finalScore));
            
            // Apply moderate non-linear transformation to show differences
            // Less aggressive than before - more realistic
            const amplifiedScore = Math.pow(finalScore, 0.85);
            
            return amplifiedScore;
        }


        // --- UI & DISPLAY FUNCTIONS ---

        /**
         * Renders the scored routes into the results panel and sets up interactivity.
         * @param {google.maps.DirectionsResult} directionsResponse - The original response from Google.
         * @param {Array<Object>} sortedRoutes - The sorted array from scoreRoutes().
         */
        function displayScoredRoutes(directionsResponse, sortedRoutes) {
            const resultsPanel = document.getElementById("results-panel");
            resultsPanel.innerHTML = ""; // Clear placeholder or old results

            // 1. Render all routes on the map (required by Google)
            directionsRenderer.setDirections(directionsResponse);

            // 2. Create a route card for each sorted route
            sortedRoutes.forEach((routeData, i) => {
                const { route, score, index } = routeData;
                const leg = route.legs[0]; // Assuming single-leg trips for simplicity

                const card = document.createElement("div");
                card.className = "route-card";
                card.setAttribute("data-route-index", index); // Store the *original* index
                card.setAttribute("tabindex", "0"); // Make card focusable

                let title = `Route ${i + 1}`;
                if (i === 0) {
                    title += " (Shadiest)";
                }

                // Generate text for speech ---
                const cardSpeech = `${title}. ${(score * 100).toFixed(0)} percent shade. 
                                     Duration: ${leg.duration.text}. Distance: ${leg.distance.text}.`;
 
                card.innerHTML = `
                    <h3 class="text-lg font-semibold text-blue-700">${title}</h3>
                    <p class="text-sm text-gray-800 font-medium">
                        Shade Score: <span class="text-xl font-bold text-green-700">${(score * 100).toFixed(0)}%</span>
                    </p>
                    <p class="text-sm text-gray-600">Distance: ${leg.distance.text}</p>
                    <p class="text-sm text-gray-600">Duration: ${leg.duration.text}</p>
                `;

                // --- Add focus listener ---
                card.addEventListener('focus', () => {
                    // Don't re-read if it was just clicked
                    if (document.activeElement === card) {
                        queueSpeech(cardSpeech);
                    }
                });

                // 3. Add click listener to highlight the route
                card.addEventListener("click", () => {
                    // Set the map's active route
                    directionsRenderer.setRouteIndex(index);
                    
                    // Update card styling
                    if (activeRouteCard) {
                        activeRouteCard.classList.remove("active");
                    }
                    card.classList.add("active");
                    activeRouteCard = card;
                    
                    // Store the selected route for tracking
                    selectedRoute = route;
                    routePath = extractRoutePath(route);
                    routeSteps = extractRouteSteps(route);
                    currentStepIndex = 0;
                    lastSpokenInstruction = ""; // <-- Reset spoken state
                    lastSpokenDirection = ""; // <-- Reset spoken state
                    
                    // Show location tracker section if route is selected
                    document.getElementById("location-tracker-section").style.display = "block";
                    
                    // If already tracking, update direction check
                    if (isTracking && currentLocation) {
                        checkDirection();
                    }

                    // --- Announce selection ---
                    queueSpeech(`Selected ${title}. Ready to start tracking.`);

                });

                resultsPanel.appendChild(card);
            });

            // 4. Automatically highlight the shadiest route
            queueSpeech("Route options are ready. The shadiest route is selected."); // Announce results are ready 

            const shadiestCard = resultsPanel.querySelector('.route-card');
            if (shadiestCard) {
                shadiestCard.click(); // Programmatically click the first card
            }
        }

        // --- LOCATION TRACKING FUNCTIONS ---

        /**
         * Extracts the path (array of LatLng points) from a route
         */
        function extractRoutePath(route) {
            const path = [];
            for (const leg of route.legs) {
                for (const step of leg.steps) {
                    const stepPath = step.path;
                    for (let i = 0; i < stepPath.length; i++) {
                        path.push(stepPath[i]);
                    }
                }
            }
            return path;
        }

        /**
         * Extracts route steps with instructions for navigation
         */
        function extractRouteSteps(route) {
            const steps = [];
            for (const leg of route.legs) {
                for (const step of leg.steps) {
                    steps.push({
                        startLocation: step.start_location,
                        endLocation: step.end_location,
                        instructions: step.instructions,
                        distance: step.distance,
                        path: step.path
                    });
                }
            }
            return steps;
        }

        /**
         * Starts tracking the user's location
         */
        function startLocationTracking() {
            queueSpeech("Starting location tracking.");

            if (!selectedRoute) {
                alert("Please select a route first by clicking on one of the route options.");
                return;
            }

            if (!navigator.geolocation) {
                alert("Geolocation is not supported by your browser.");
                return;
            }

            isTracking = true;
            document.getElementById("start-tracking-btn").style.display = "none";
            document.getElementById("stop-tracking-btn").style.display = "block";
            document.getElementById("status-text").textContent = "Tracking...";
            document.getElementById("tracking-status").className = "p-3 rounded-lg mb-3 tracking";

            // Start listening to device orientation for compass heading
            startDeviceOrientationTracking();

            // Watch position with high accuracy
            watchId = navigator.geolocation.watchPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    currentLocation = new google.maps.LatLng(lat, lng);
                    
                    
                    // Use heading from geolocation if device orientation not available
                    if (position.coords.heading !== null && position.coords.heading !== undefined && deviceHeading === null) {
                        deviceHeading = position.coords.heading;
                    }

                    // Update or create marker
                    if (!currentLocationMarker) {
                        currentLocationMarker = new google.maps.Marker({
                            position: currentLocation,
                            map: map,
                            icon: {
                                path: google.maps.SymbolPath.CIRCLE,
                                scale: 8,
                                fillColor: "#2563eb",
                                fillOpacity: 1,
                                strokeColor: "#ffffff",
                                strokeWeight: 2
                            },
                            title: "Your Location",
                            zIndex: 1000
                        });
                    } else {
                        currentLocationMarker.setPosition(currentLocation);
                    }

                    // Smoothly pan map to follow user (only if zoomed in enough)
                    if (map.getZoom() >= 14) {
                        map.panTo(currentLocation);
                    } else {
                        map.setCenter(currentLocation);
                        map.setZoom(16);
                    }

                    // Check direction and update UI
                    checkDirection();

                    // Draw direction indicator if we have previous location
                    if (previousLocation) {
                        drawDirectionIndicator(previousLocation, currentLocation);
                    }

                    // Update navigation arrow pointing to route
                    updateNavigationArrow();

                    previousLocation = currentLocation;
                },
                (error) => {
                    console.error("Geolocation error:", error);
                    let errorMsg = "Error getting location: ";
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            errorMsg += "Permission denied. Please enable location services.";
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMsg += "Position unavailable.";
                            break;
                        case error.TIMEOUT:
                            errorMsg += "Request timeout.";
                            break;
                        default:
                            errorMsg += "Unknown error.";
                            break;
                    }
                    alert(errorMsg);
                    queueSpeech(errorMsg, true);
                    stopLocationTracking();
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        }

        /**
         * Stops tracking the user's location
         */
        function stopLocationTracking() {
            queueSpeech("Stopping location tracking.");
            lastSpokenDirection = "";
            lastSpokenInstruction = "";

            isTracking = false;
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }

            document.getElementById("start-tracking-btn").style.display = "block";
            document.getElementById("stop-tracking-btn").style.display = "none";
            document.getElementById("status-text").textContent = "Not tracking";
            document.getElementById("tracking-status").className = "p-3 rounded-lg mb-3";
            document.getElementById("distance-text").textContent = "-";
            document.getElementById("direction-indicator").textContent = "Tracking stopped";
            document.getElementById("direction-indicator").className = "text-sm font-semibold";

            // Remove direction polyline
            if (directionPolyline) {
                directionPolyline.setMap(null);
                directionPolyline = null;
            }

            // Remove navigation arrow
            if (navigationArrow) {
                navigationArrow.setMap(null);
                navigationArrow = null;
            }

            // Stop device orientation tracking
            stopDeviceOrientationTracking();

            // Hide compass
            document.getElementById("compass-container").style.display = "none";

            previousLocation = null;
            deviceHeading = null;
        }

        /**
         * Checks if the user is going in the right direction
         */
        function checkDirection() {
            if (!currentLocation || !routePath || routePath.length === 0) {
                return;
            }

            // Find the closest point on the route and next waypoint
            let minDistance = Infinity;
            let closestPointIndex = 0;
            let closestPoint = routePath[0];
            let nextWaypoint = null;
            let nextWaypointIndex = 0;

            for (let i = 0; i < routePath.length; i++) {
                const distance = google.maps.geometry.spherical.computeDistanceBetween(
                    currentLocation,
                    routePath[i]
                );
                if (distance < minDistance) {
                    minDistance = distance;
                    closestPointIndex = i;
                    closestPoint = routePath[i];
                }
            }

            // Find next waypoint ahead on the route (look ahead 20-50 points)
            const lookAheadStart = Math.min(closestPointIndex + 10, routePath.length - 1);
            const lookAheadEnd = Math.min(closestPointIndex + 50, routePath.length - 1);
            
            if (lookAheadStart < routePath.length) {
                nextWaypointIndex = lookAheadEnd;
                nextWaypoint = routePath[nextWaypointIndex];
            } else {
                // We're near the end, use destination
                nextWaypoint = routePath[routePath.length - 1];
                nextWaypointIndex = routePath.length - 1;
            }

            // Calculate distance to route
            const distanceToRoute = minDistance; // in meters
            const distanceText = distanceToRoute < 1000 
                ? `${Math.round(distanceToRoute)}m` 
                : `${(distanceToRoute / 1000).toFixed(2)}km`;
            
            document.getElementById("distance-text").textContent = distanceText;

            // Calculate distance to next waypoint
            if (nextWaypoint) {
                const distanceToNext = google.maps.geometry.spherical.computeDistanceBetween(
                    currentLocation,
                    nextWaypoint
                );
                const nextDistanceText = distanceToNext < 1000 
                    ? `${Math.round(distanceToNext)}m` 
                    : `${(distanceToNext / 1000).toFixed(2)}km`;
                document.getElementById("next-turn-text").textContent = nextDistanceText;
            }

            // Determine if user is on track (within 50 meters is considered on track)
            const onTrackThreshold = 50; // meters
            const isOnTrack = distanceToRoute <= onTrackThreshold;

            // Check direction of travel
            let directionMessage = "";
            let directionClass = "";

            if (previousLocation && currentLocation) {
                // Calculate user's direction of travel
                const userHeading = google.maps.geometry.spherical.computeHeading(
                    previousLocation,
                    currentLocation
                );

                // Calculate direction to next waypoint (better for navigation)
                const targetPoint = nextWaypoint || closestPoint;
                const headingToTarget = google.maps.geometry.spherical.computeHeading(
                    currentLocation,
                    targetPoint
                );

                // Calculate angle difference
                let angleDiff = Math.abs(userHeading - headingToTarget);
                if (angleDiff > 180) {
                    angleDiff = 360 - angleDiff;
                }

                if (isOnTrack) {
                    directionMessage = "‚úì On the right track!";
                    directionClass = "on-track";
                } else if (angleDiff < 45) {
                    directionMessage = "‚Üí Heading in the right direction";
                    directionClass = "on-track";
                } else if (angleDiff < 90) {
                    directionMessage = "‚Üó Slightly off course";
                    directionClass = "off-track";
                } else {
                    directionMessage = "‚ö† Going in wrong direction";
                    directionClass = "off-track";
                }
            } else {
                if (isOnTrack) {
                    directionMessage = "‚úì On the route";
                    directionClass = "on-track";
                } else {
                    directionMessage = "üìç Move closer to the route";
                    directionClass = "off-track";
                }
            }

            document.getElementById("direction-indicator").textContent = directionMessage;
            document.getElementById("direction-indicator").className = `text-sm font-semibold ${directionClass}`;
            document.getElementById("tracking-status").className = `p-3 rounded-lg mb-3 ${directionClass}`;
        
            // --- SPEECH LOGIC ---
            // 1. Check for turn-by-turn instructions
            if (routeSteps && currentStepIndex < routeSteps.length) {
                const currentStep = routeSteps[currentStepIndex];
                const endOfStep = currentStep.end_location;
                const distanceToStepEnd = google.maps.geometry.spherical.computeDistanceBetween(currentLocation, endOfStep);

                // If user is close to the end of the current step (e.g., within 20m) and not at the last step
                if (distanceToStepEnd < 20 && currentStepIndex < routeSteps.length - 1) {
                    currentStepIndex++; // Move to the next step
                    const nextStep = routeSteps[currentStepIndex];
                    const instructionText = nextStep.instructions.replace(/<[^>]*>/g, ''); // Clean HTML
                    
                    if (instructionText && instructionText !== lastSpokenInstruction) {
                        queueSpeech(instructionText);
                        lastSpokenInstruction = instructionText;
                        lastSpokenDirection = ""; // Reset direction to allow it to be spoken
                    }
                }
            }

            // 2. Announce direction/status changes (like "Off route")
            // Only speak if the message is new and different from the last instruction
            if (directionMessage && 
                directionMessage !== lastSpokenDirection && 
                directionMessage !== lastSpokenInstruction) {
                
                // Don't say "On the right track" if we just gave an instruction
                if (directionMessage === "‚úì On the right track!" && lastSpokenInstruction) {
                    // It's a bit spammy, so skip
                } else {
                    queueSpeech(directionMessage);
                }
                lastSpokenDirection = directionMessage;
            }
        
        }

        /**
         * Draws a line indicating the direction the user is moving
         */
        function drawDirectionIndicator(from, to) {
            if (directionPolyline) {
                directionPolyline.setPath([from, to]);
            } else {
                directionPolyline = new google.maps.Polyline({
                    path: [from, to],
                    geodesic: true,
                    strokeColor: "#2563eb",
                    strokeOpacity: 0.6,
                    strokeWeight: 4,
                    map: map,
                    zIndex: 999
                });
            }
        }

        /**
         * Starts tracking device orientation for compass heading
         */
        function startDeviceOrientationTracking() {
            // Try DeviceOrientationEvent API first (iOS 13+)
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            window.addEventListener('deviceorientation', handleDeviceOrientation);
                            deviceOrientationListener = 'deviceorientation';
                        }
                    })
                    .catch(console.error);
            } else if (window.DeviceOrientationEvent) {
                // Standard device orientation API
                window.addEventListener('deviceorientation', handleDeviceOrientation);
                deviceOrientationListener = 'deviceorientation';
            } else if (window.DeviceMotionEvent) {
                // Fallback to device motion
                window.addEventListener('devicemotion', handleDeviceMotion);
                deviceOrientationListener = 'devicemotion';
            }
        }

        /**
         * Stops tracking device orientation
         */
        function stopDeviceOrientationTracking() {
            if (deviceOrientationListener === 'deviceorientation') {
                window.removeEventListener('deviceorientation', handleDeviceOrientation);
            } else if (deviceOrientationListener === 'devicemotion') {
                window.removeEventListener('devicemotion', handleDeviceMotion);
            }
            deviceOrientationListener = null;
        }

        /**
         * Handles device orientation events
         */
        function handleDeviceOrientation(event) {
            if (event.alpha !== null && event.alpha !== undefined) {
                // alpha is the compass heading (0-360 degrees)
                // Convert to Google Maps heading (0 = North, clockwise)
                deviceHeading = event.alpha;
                updateNavigationArrow();
            }
        }

        /**
         * Handles device motion events (fallback)
         */
        function handleDeviceMotion(event) {
            // This is a fallback, less accurate than orientation
            if (event.rotationRate && event.rotationRate.alpha !== null) {
                // This is rotation rate, not absolute heading, so we'd need to integrate
                // For now, we'll rely on geolocation heading
            }
        }

        /**
         * Updates the navigation arrow pointing toward the route
         */
        function updateNavigationArrow() {
            if (!currentLocation || !routePath || routePath.length === 0) {
                return;
            }

            // Find closest point on route
            let minDistance = Infinity;
            let closestPoint = routePath[0];
            let closestIndex = 0;

            for (let i = 0; i < routePath.length; i++) {
                const distance = google.maps.geometry.spherical.computeDistanceBetween(
                    currentLocation,
                    routePath[i]
                );
                if (distance < minDistance) {
                    minDistance = distance;
                    closestPoint = routePath[i];
                    closestIndex = i;
                }
            }

            // Find next waypoint ahead
            const nextIndex = Math.min(closestIndex + 30, routePath.length - 1);
            const nextPoint = routePath[nextIndex];

            // Calculate heading from user to next point (direction to go)
            const headingToRoute = google.maps.geometry.spherical.computeHeading(
                currentLocation,
                nextPoint
            );

            // Use device heading to rotate arrow with device orientation
            let arrowRotation = headingToRoute;
            let compassArrow = headingToRoute;

            if (deviceHeading !== null && deviceHeading !== undefined) {
                // Arrow should point in the direction the device is facing
                // deviceHeading is where device is pointing (0-360, 0 = North)
                // Convert to Google Maps format (0 = North, clockwise, -180 to 180)
                let deviceHeadingMaps = deviceHeading;
                if (deviceHeadingMaps > 180) {
                    deviceHeadingMaps = deviceHeadingMaps - 360;
                }
                
                // Arrow rotates with device - always points where device is facing
                arrowRotation = deviceHeadingMaps;
                compassArrow = deviceHeadingMaps;
            }

            // Convert heading to arrow direction for compass display
            const arrow = getArrowFromHeading(compassArrow);
            document.getElementById("compass-arrow").textContent = arrow;
            document.getElementById("compass-container").style.display = "block";

            // Update navigation arrow marker on map
            // Arrow rotates with device orientation
            const finalRotation = arrowRotation;

            if (!navigationArrow) {
                navigationArrow = new google.maps.Marker({
                    position: currentLocation,
                    map: map,
                    icon: {
                        path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
                        scale: 5,
                        rotation: finalRotation,
                        fillColor: "#10b981",
                        fillOpacity: 0.8,
                        strokeColor: "#ffffff",
                        strokeWeight: 2
                    },
                    zIndex: 1001
                });
            } else {
                navigationArrow.setPosition(currentLocation);
                navigationArrow.setIcon({
                    path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
                    scale: 5,
                    rotation: finalRotation,
                    fillColor: "#10b981",
                    fillOpacity: 0.8,
                    strokeColor: "#ffffff",
                    strokeWeight: 2
                });
            }
        }

        /**
         * Converts heading (degrees) to arrow emoji
         */
        function getArrowFromHeading(heading) {
            // Normalize heading to 0-360
            let normalizedHeading = heading;
            if (normalizedHeading < 0) {
                normalizedHeading += 360;
            }

            // Convert to 8 directions
            // Handle North separately (wraps around 0)
            if (normalizedHeading >= 337.5 || normalizedHeading < 22.5) {
                return "‚Üë";   // North
            } else if (normalizedHeading >= 22.5 && normalizedHeading < 67.5) {
                return "‚Üó";   // Northeast
            } else if (normalizedHeading >= 67.5 && normalizedHeading < 112.5) {
                return "‚Üí";   // East
            } else if (normalizedHeading >= 112.5 && normalizedHeading < 157.5) {
                return "‚Üò";  // Southeast
            } else if (normalizedHeading >= 157.5 && normalizedHeading < 202.5) {
                return "‚Üì";   // South
            } else if (normalizedHeading >= 202.5 && normalizedHeading < 247.5) {
                return "‚Üô";   // Southwest
            } else if (normalizedHeading >= 247.5 && normalizedHeading < 292.5) {
                return "‚Üê";   // West
            } else if (normalizedHeading >= 292.5 && normalizedHeading < 337.5) {
                return "‚Üñ";   // Northwest
            }

            return "‚Üí"; // Default
        }


        // --- SPEECH FUNCTIONS ---

        /**
         * Stops any currently playing audio and clears it.
         */
        function stopCurrentSpeech() {
            if (currentAudio) {
                currentAudio.onended = null;
                currentAudio.onerror = null;
                currentAudio.pause();
                currentAudio.src = ""; // Detach the audio source
                currentAudio = null;
            }
            // Also stop the browser's built-in speech, just in case
            window.speechSynthesis.cancel();
            
            isSpeaking = false; // Tell the queue system it's free
        }

        /**
         * Adds text to the speech queue and starts processing.
         * @param {string} text - The text to be spoken.
         * @param {boolean} [force=false] - If true, speaks even if isSpeechEnabled is false (for alerts).
         */
        function queueSpeech(text, force = false) {
            if (!isSpeechEnabled && !force) {
                return; // Speech is off, do nothing
            }

            // Don't queue the same message back-to-back
            if (speechQueue.length > 0 && speechQueue[speechQueue.length - 1] === text) {
                return;
            }
            if (isSpeaking && lastSpokenInstruction === text) {
                return;
            }

            console.log("Queueing speech:", text);
            speechQueue.push(text);
            
            if (!isSpeaking) {
                processSpeechQueue();
            }
        }

        /**
         * Processes the next item in the speech queue.
         */
        function processSpeechQueue() {
            if (isSpeaking || speechQueue.length === 0) {
                return; // Already speaking or queue is empty
            }

            isSpeaking = true;
            const textToSpeak = speechQueue.shift(); // Get the next item
            
            // Clean up text (e.g., remove HTML tags)
            const cleanText = textToSpeak.replace(/<[^>]*>/g, '');
            
            speakText(cleanText);
        }

        /**
         * Sends text to ElevenLabs API and plays the returned audio.
         * @param {string} text - The plain text to speak.
         */
        async function speakText(text) {
            if (!text || text.trim().length === 0) {
                isSpeaking = false;
                processSpeechQueue(); // Move to next item
                return;
            }

            // Stop any previous audio before starting a new one
            stopCurrentSpeech();

            const url = 'http://localhost:3000/api/speak'; // Calls your server
            const options = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    text: text
                })
            };

            try {
                const response = await fetch(url, options);
                
                if (!response.ok) {
                    throw new Error(`Server error: ${response.statusText}`);
                }
                
                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);
                
                // --- MODIFICATION START ---
                // Create a new audio object and assign it to the global variable
                currentAudio = new Audio(audioUrl);
                
                // Update the pause button text
                document.getElementById('pause-btn').textContent = "‚è∏Ô∏è";
                
                currentAudio.play();

                // When audio finishes, set isSpeaking to false and process the next item
                currentAudio.onended = () => {
                    isSpeaking = false;
                    currentAudio = null; // Clear the global variable
                    processSpeechQueue();
                };

                // Add an error handler
                currentAudio.onerror = () => {
                    console.error("Error playing audio file.");
                    isSpeaking = false;
                    currentAudio = null;
                    processSpeechQueue();
                }
                // --- MODIFICATION END ---

            } catch (error) {
                console.error("Error with speech synthesis:", error);
                isSpeaking = false; // Ensure we can continue
                currentAudio = null; // Clear on error
                processSpeechQueue(); // Try the next item
            }
        }

    </script>
</body>

</html>


