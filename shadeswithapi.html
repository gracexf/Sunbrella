<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shade-Seeker Map</title>
    <!-- 1. Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. Load SunCalc.js for sun position calculation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>
    <style>
        /* Basic layout styling */
        body {
            display: flex;
            height: 100vh;
            margin: 0;
            font-family: 'Inter', sans-serif;
        }
        #sidebar {
            width: 400px;
            height: 100%;
            overflow-y: auto;
            background-color: #f8fafc;
            border-right: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
        }
        #map {
            width: 100%;
            height: 100%;
        }
        /* Custom styles for inputs */
        .map-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 12px;
        }
        .map-button {
            width: 100%;
            padding: 12px;
            background-color: #2563eb;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .map-button:hover {
            background-color: #1d4ed8;
        }
        .map-button:disabled {
            background-color: #94a3b8;
            cursor: not-allowed;
        }
        /* Style for the route cards */
        .route-card {
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        .route-card:hover {
            background-color: #ffffff;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .route-card.active {
            border-color: #2563eb;
            background-color: #eff6ff;
            border-width: 2px;
        }
    </style>
</head>
<body class="bg-gray-100">

    <!-- Sidebar for controls and results -->
    <div id="sidebar" class="p-6 shadow-lg">
        <h1 class="text-3xl font-bold text-gray-800 mb-6">Shade-Seeker</h1>
        
        <div classs="mb-4">
            <label for="origin-input" class="block text-sm font-medium text-gray-700 mb-1">Origin</label>
            <input type="text" id="origin-input" class="map-input" placeholder="Enter starting address">
        </div>

        <div class="mb-4">
            <label for="destination-input" class="block text-sm font-medium text-gray-700 mb-1">Destination</label>
            <input type="text" id="destination-input" class="map-input" placeholder="Enter destination">
        </div>

        <div class="mb-6">
            <label for="time-input" class="block text-sm font-medium text-gray-700 mb-1">Time of Travel</label>
            <input type="datetime-local" id="time-input" class="map-input">
        </div>

        <button id="find-route-btn" class="map-button">Find Shadiest Route</button>

        <!-- Divider -->
        <hr class="my-6 border-gray-300">

        <!-- Area where route results will be injected -->
        <h2 class="text-xl font-semibold text-gray-800 mb-4">Route Options</h2>
        <div id="results-panel" class="flex-1">
            <p id="results-placeholder" class="text-gray-500">Enter a start and end point to see the shadiest routes.</p>
        </div>
    </div>

    <!-- Main map area -->
    <div id="map"></div>

    <!-- 3. Load Google Maps API -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCLnFaXl5bdOM55J-GMb3QIJaTDp0IkyCU&callback=initMap&libraries=places,geometry&v=weekly" async defer></script>

    <script>
        // --- GLOBAL VARIABLES ---
        let map;
        let directionsService;
        let directionsRenderer;
        let originAutocomplete;
        let destinationAutocomplete;
        let lastDirectionsResponse = null; // To store the last response
        let activeRouteCard = null; // To track the active card

        // --- INITIALIZATION ---

        /**
         * This is the main callback function for the Google Maps script.
         * It initializes the map and all related services.
         */
        function initMap() {
            // Center the map on a default location (e.g., a central US location)
            // You can change this to your hackathon's city
            const defaultCenter = { lat: 39.8283, lng: -98.5795 }; 

            map = new google.maps.Map(document.getElementById("map"), {
                center: defaultCenter,
                zoom: 5,
                mapTypeControl: false,
                streetViewControl: false,
            });

            // Initialize the services we need
            directionsService = new google.maps.DirectionsService();
            directionsRenderer = new google.maps.DirectionsRenderer({
                map: map,
                panel: document.getElementById("results-panel"), // We'll manually build our own panel
                hideRouteList: true // Hide the default A, B, C list
            });

            // Set up Autocomplete for the input fields
            const originInput = document.getElementById("origin-input");
            const destinationInput = document.getElementById("destination-input");
            
            originAutocomplete = new google.maps.places.Autocomplete(originInput, {
                fields: ["place_id", "name", "geometry"],
            });
            destinationAutocomplete = new google.maps.places.Autocomplete(destinationInput, {
                fields: ["place_id", "name", "geometry"],
            });

            // Set default date/time to now
            const now = new Date();
            now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
            now.setSeconds(0); // Clear seconds
            now.setMilliseconds(0); // Clear milliseconds
            document.getElementById("time-input").value = now.toISOString().slice(0, 16);

            // Add listener to the 'Find Route' button
            document.getElementById("find-route-btn").addEventListener("click", calculateAndDisplayRoute);
        }

        // --- CORE LOGIC ---

        /**
         * Called when the "Find Route" button is clicked.
         * Fetches routes and then triggers the scoring and display.
         */
        async function calculateAndDisplayRoute() {
            const findRouteBtn = document.getElementById("find-route-btn");
            const resultsPlaceholder = document.getElementById("results-placeholder");

            // Show loading state
            findRouteBtn.disabled = true;
            findRouteBtn.textContent = "Calculating...";
            resultsPlaceholder.textContent = "Finding the best routes...";
            
            const origin = document.getElementById("origin-input").value;
            const destination = document.getElementById("destination-input").value;
            const timeValue = document.getElementById("time-input").value;

            if (!origin || !destination || !timeValue) {
                alert("Please fill out all fields.");
                findRouteBtn.disabled = false;
                findRouteBtn.textContent = "Find Shadiest Route";
                return;
            }

            const travelTime = new Date(timeValue);

            // 1. Create the Directions Request
            const request = {
                origin: origin,
                destination: destination,
                travelMode: 'WALKING', // Shade is most relevant for walking!
                provideRouteAlternatives: true // This is KEY to getting multiple options
            };

            // 2. Call the Directions Service
            directionsService.route(request, (response, status) => {
                findRouteBtn.disabled = false;
                findRouteBtn.textContent = "Find Shadiest Route";

                if (status === 'OK') {
                    // Store the response so we can interact with it later
                    lastDirectionsResponse = response; 
                    
                    // 3. Score the routes
                    const sortedRoutes = scoreRoutes(response.routes, travelTime);

                    // 4. Display the routes and cards
                    displayScoredRoutes(response, sortedRoutes);

                } else {
                    alert('Directions request failed due to ' + status);
                    resultsPlaceholder.textContent = "No routes found. Try a different search.";
                }
            });
        }

        /**
         * Takes the routes and the time, then scores and sorts them by shade.
         * @param {Array<google.maps.DirectionsRoute>} routes - The array of routes from the response.
         * @param {Date} dateTime - The time of travel.
         * @returns {Array<Object>} A sorted array of {route, score, index} objects.
         */
        function scoreRoutes(routes, dateTime) {
            console.log("Scoring routes for time:", dateTime);

            // Get the sun position for the route's start location
            // We assume sun position doesn't change *drastically* during a walk
            const startLocation = routes[0].legs[0].start_location;
            const sunPosition = SunCalc.getPosition(dateTime, startLocation.lat(), startLocation.lng());
            
            // sunPosition.altitude is in radians (0 at horizon, PI/2 at zenith)
            
            // 1. Calculate the Sun Altitude Modifier
            // Math.cos(0) = 1 (long shadows, high score impact)
            // Math.cos(PI/2) = 0 (no shadows, score is 0)
            // This is a powerful and realistic modifier!
            const sunModifier = Math.cos(sunPosition.altitude);
            console.log(`Sun Altitude: ${sunPosition.altitude.toFixed(2)} rad, Sun Modifier: ${sunModifier.toFixed(2)}`);

            // If it's night, sunModifier will be negative (altitude < 0).
            // Let's just say at night, all routes are 100% shade.
            if (sunPosition.altitude < 0) {
                console.log("It's night. All routes are 100% shade.");
                return routes.map((route, index) => ({
                    route: route,
                    score: 1.0, // 100% shade score
                    index: index
                }));
            }

            // 2. Score and store each route
            const scoredRoutes = routes.map((route, index) => {
                const rawShadeScore = calculateRawShade(route);
                const finalScore = rawShadeScore * sunModifier;

                return {
                    route: route,      // The original route object
                    score: finalScore,   // The final calculated score (0.0 to 1.0)
                    index: index       // The original index in the response array
                };
            });

            // 3. Sort the routes by score, descending (shadiest first)
            scoredRoutes.sort((a, b) => b.score - a.score);
            
            console.log("Scored routes:", scoredRoutes);
            return scoredRoutes;
        }

        /**
         * This is the core heuristic engine.
         * It analyzes the *text instructions* for each step of a route.
         * @param {google.maps.DirectionsRoute} route - A single route to analyze.
         * @returns {number} A "raw" shade score from 0.0 to 1.0.
         */
        function calculateRawShade(route) {
            let totalDistance = 0;
            let weightedShadeScore = 0;

            for (const leg of route.legs) {
                for (const step of leg.steps) {
                    const stepDistance = step.distance.value; // in meters
                    const instructions = step.instructions.toLowerCase();
                    
                    totalDistance += stepDistance;
                    
                    // The Heuristic Model
                    let shadeFactor = 0.5; // Default (e.g., standard street)

                    if (instructions.includes("tunnel")) {
                        shadeFactor = 1.0; // Max shade
                    } else if (instructions.includes("park") || instructions.includes("greenway") || instructions.includes("trail")) {
                        shadeFactor = 0.8; // High shade (trees)
                    } else if (instructions.includes("plaza") || instructions.includes("square") || instructions.includes("courtyard")) {
                        shadeFactor = 0.2; // Low shade (open area)
                    } else if (instructions.includes("highway") || instructions.includes("bridge") || instructions.includes("overpass")) {
                        shadeFactor = 0.1; // No shade
                    }

                    weightedShadeScore += stepDistance * shadeFactor;
                }
            }

            return (totalDistance > 0) ? (weightedShadeScore / totalDistance) : 0.5;
        }


        // --- UI & DISPLAY FUNCTIONS ---

        /**
         * Renders the scored routes into the results panel and sets up interactivity.
         * @param {google.maps.DirectionsResult} directionsResponse - The original response from Google.
         * @param {Array<Object>} sortedRoutes - The sorted array from scoreRoutes().
         */
        function displayScoredRoutes(directionsResponse, sortedRoutes) {
            const resultsPanel = document.getElementById("results-panel");
            resultsPanel.innerHTML = ""; // Clear placeholder or old results

            // 1. Render all routes on the map (required by Google)
            directionsRenderer.setDirections(directionsResponse);

            // 2. Create a route card for each sorted route
            sortedRoutes.forEach((routeData, i) => {
                const { route, score, index } = routeData;
                const leg = route.legs[0]; // Assuming single-leg trips for simplicity

                const card = document.createElement("div");
                card.className = "route-card";
                card.setAttribute("data-route-index", index); // Store the *original* index

                let title = `Route ${i + 1}`;
                if (i === 0) {
                    title += " (Shadiest)";
                }

                card.innerHTML = `
                    <h3 class="text-lg font-semibold text-blue-700">${title}</h3>
                    <p class="text-sm text-gray-800 font-medium">
                        Shade Score: <span class="text-xl font-bold text-green-700">${(score * 100).toFixed(0)}%</span>
                    </p>
                    <p class="text-sm text-gray-600">Distance: ${leg.distance.text}</p>
                    <p class="text-sm text-gray-600">Duration: ${leg.duration.text}</p>
                `;

                // 3. Add click listener to highlight the route
                card.addEventListener("click", () => {
                    // Set the map's active route
                    directionsRenderer.setRouteIndex(index);
                    
                    // Update card styling
                    if (activeRouteCard) {
                        activeRouteCard.classList.remove("active");
                    }
                    card.classList.add("active");
                    activeRouteCard = card;
                });

                resultsPanel.appendChild(card);
            });

            // 4. Automatically highlight the shadiest route
            const shadiestCard = resultsPanel.querySelector('.route-card');
            if (shadiestCard) {
                shadiestCard.click(); // Programmatically click the first card
            }
        }

    </script>
</body>

</html>
